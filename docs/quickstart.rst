Quickstart
**********

Introduction
============

``nrt-validate`` is a namespace package that extends `nrt <https://nrt.readthedocs.io/en/latest/index.html>`_
with utilities for accuracy and performance assessment of monitoring algorithms and
their outputs. In particular it contains:

- A customizable user interface for creating reference data through visual interpretation of spatio-temporal data.
  The interface is largely inspired by the timeSync tool (Cohen, Yang & Kennedy, 2010) [1]_,
  by combining elements of the spatial and temporal context together with very high resolution imagery
  in a single interface, it allows an interpreter to fully benefit from the various data dimensions for accurate
  identification of land dynamics.
  The interface is suitable for a local deployment on any PC via the `jupyter voilà framework <https://voila.readthedocs.io/en/stable/>`_,
  and requires minimal preparation from the user side (data used as visual support for visual interpretation can be fetched directly from
  a cloud archive thanks to the `STACLoader` loader)  
- A sampling utility to create a set of sampling location for a given sampling design and handle the sample set (subsetting, augmenting, etc)
- Multiple estimators of accuracy
- The timeliness metric proposed by Bullock et al. (2022) [2]_


Installation
============

Install the package from pypi using:

.. code-block::

	pip install nrt-validate


When planning to use the user interface, it is probably necessary to also install ``voila`` (for serving the interface as a local dashboard) and ``fiona`` (often needed to load features contained in a vector file as an in-memory feature collection).

.. code-block::

	pip install voila fiona


Workflow
========

In general a workflow with the `nrt` package can be divided into three parts: 
Instantiating, Fitting and Monitoring.

Instantiating
-------------

.. code-block:: python

    from nrt.monitor.ewma import EWMA
    from nrt import data

    # load example mask
    mask = (data.romania_forest_cover_percentage() > 20).astype('int')

    # Instantiate
    nrt_class = EWMA(
        mask=mask,
        trend=True,
        harmonic_order=3,
        sensitivity=2
    )

Here, the monitoring class ``EWMA`` is imported. Along with that a forest mask
is constructed. This mask is optional but must have the same shape as the data array which is
later supplied for fitting.

All available monitoring classes accept the parameters ``mask``, ``trend``, ``harmonic_order``
and ``sensitivity``. Some monitoring classes also accept additional parameters.
For more information see :ref:`classes`.

.. note::
    ``sensitivity`` takes different values depending on the monitoring class.
    For example larger ``sensitivity`` values mean higher sensitivity for ``EWMA``,
    but lower sensitivity for ``MoSum``.



Fitting
-------------

.. code-block:: python
    
    # load example xarray
    s2_cube = data.romania_20m()
    history = s2_cube.B3.sel(time=slice(None, '2019-01-01'))
    monitor = s2_cube.B3.sel(time=slice('2019-01-01', None))

    # Fitting
    nrt_class.fit(dataarray=history)

    # Dump model
    nrt_class.to_netcdf('model.nc')

In this example some sample data is created first, which is used for fitting and 
later for monitoring. 
``.fit()`` has only one non optional parameter ``dataarray`` which expects an 
``xarray.DataArray``. During fitting there are other optional parameters which can be set. 
See :ref:`fitting` for more detail.

If the next observation is not immediately available, the model can be dumped
to a NetCDF file which can then be loaded once the next observation is available.

Monitoring
-------------

.. code-block:: python
    
    # Load dumped model
    nrt_class = EWMA.from_netcdf('model.nc')

    # Monitor new observations
    for array, date in zip(monitor.values, monitor.time.values.astype('datetime64[s]').tolist()):
        nrt_class.monitor(array=array, date=date)

    # Report results
    nrt_class.report('report.tif')

If the model was dumped to a NetCDF it can be read from disk with ``from_netcdf()``.
Monitoring happens with ``.monitor()``. This only takes an numpy array and a date of class
``datetime.date``. 

At any time during monitoring a report can be generated by calling 
``.report()``. This report returns a GeoTIFF with two bands, one showing the status 
of all pixels (e.g. not monitored, disturbed, etc.) and another band showing the date when 
a disturbance was detected in days since 1970-01-01.

References
==========

.. [1] Cohen, W. B., Yang, Z., & Kennedy, R., 2010.
       Detecting trends in forest disturbance and recovery using yearly Landsat time series:
       2. TimeSync—Tools for calibration and validation. Remote Sensing of Environment, 114(12), 2911-2924.
       https://doi.org/10.1016/j.rse.2010.07.010
	
.. [2] Bullock, E.L., Healey, S.P., Yang, Z., Houborg, R., Gorelick, N., Tang, X. and Andrianirina, C., 2022.
       Timeliness in forest change monitoring: A new assessment framework demonstrated using Sentinel-1 and a continuous change detection algorithm.
       Remote Sensing of Environment, 276, p.113043.
       https://doi.org/10.1016/j.rse.2022.113043	
